Úkolem je vytvořit část programu, který umožní rychlou analýzu záběrů z kamerového systému letiště. Implementace bude využívat vlákna k tomu, aby na předložených snímcích vyhledala obrazy hledaných teroristů.

Předpokládáme, že na letišti existuje kamerový systém, který na požádání dodá aktuální snímek. Tomuto systému budeme říkat scanner. Dále předpokládáme, že existuje obrazová databáze hledaných teroristů. Pro jednoduchost předpokládáme, že databáze má nejvýše 32 položek. Konečně, máme k dispozici rozhraní na zodpovědného bezpečnostního pracovníka (officer), kterému předáváme vyhodnocené snímky s informací, zda na nich jsou nějací z hledaných teroristů nebo ne.

Vaším úkolem bude implementovat část programu, která bude žádat o snímky ze scanneru, ve získaném snímku bude vyhledávat hledané teroristy z databáze a o výsledcích hledání bude informovat příslušného pracovníka (officer). Naší snahou je zpracovávat co nejvíce snímků a co nejrychleji. Proto použijeme řešení s vlákny, které dokáže výpočetní zátěž rozložit na více procesorů/jader.

Vaším úkolem je využít následující rozhraní a implementovat funkci TerroristHunter:

#ifndef __PROGTEST__
typedef struct TImage
 {  
   int              m_W;   
   int              m_H;   
   unsigned char ** m_Data;
 } TIMAGE;

void  TerroristHunter    ( int        databaseSize,
                           TIMAGE  ** database,
                           int        threads,
                           TIMAGE *(* scanner) ( void ),
                           void    (* officer) ( TIMAGE *, int ) );
#endif /* __PROGTEST__ */
Význam deklarací je následující:
Struktura TIMAGE reprezentuje jeden obrázek. Složka m_W udává šířku a m_H výšku obrázku. Vlastní obrazová data jsou předaná v podobě 2D pole m_Data. Toto pole obsahuje m_H řádek a m_W sloupců, v každém je uložena "barva" - odstín šedé od 0 do 254. Hodnota 255 má zvláštní význam, viz níže.
Funkce TerroristHunter je rozhraní pro Vaší implementaci. Tato funkce zajišťuje celý proces získávání/zpracování/odevzdávání obrazů. Má následující parametry:
databaseSize udává počet hledaných teroristů v databázi. Celkový počet je vždy maximálně 32.
database je pole odkazů na obrázky hledaných teroristů. Pole má vyplněno prvních databaseSize položek.
threads je počet pracovních vláken, která má Vaše implementace vytvořit. Mezi tato vlákna se bude rozkládat výpočetní zátěž.
scanner je ukazatel na funkci generující snímek. Vaše implementace bude tuto funkci volat vždy, když bude potřebovat další snímek ke zpracování. Funkce vrátí ukazatel na načtený snímek nebo hodnotu NULL, pokud již další snímky nejsou k dispozici (konec směny).
officer je ukazatel na funkci, které budete odevzdávat zpracované a vyhodnocené snímky. Parametrem funkce je zpracovaný snímek (ukazatel na něj, tak jak jste jej obdrželi z funkce scanner) a pole příznaků, kteří teroristé byli na snímku detekování. Druhý parametr (hodnotu int) chápejte jako bitové pole, kde každému bitu odpovídá jeden terorista z databáze (bit 0 bude mít hodnotu 1 pokud obrázek obsahoval teroristu z database[0], bit 1 bude mít hodnotu 1 pokud obrázek obsahoval teroristu z database[1], ...). Každý zpracovávaný obrázek předávejte touto funkcí pouze jednou, v okamžiku kdy již vyhodnotíte přítomnost/nepřítomnost všech hledaných teroristů z databáze.
Vaše implementace bude mít následující hrubou strukturu:

Inicializuje Vaše struktury (fronty), do kterých budete ukládat zpracovávané požadavky.
Vytvoří threads vláken, každé z těchto vláken bude podle potřeby vyhledávat teroristy z databáze ve zpracovávaných obrazech.
Vytvoří vlákno, které bude volat scanner a bude rozdělovat práci mezi ostatní vlákna. Pro tuto činnost můžete vytvořit buď samostatné nové vlákno, nebo můžete využít vlákno, které vyvolalo funkci TerroristHunter.
Vlákna zpracovávají příchozí požadavky, po vyhodnocení vracejí výsledky hledání (i výsledky negativní) rozhraním officer.
Po zpracování všech požadavků (scanner začne vracet NULL) ukončíte vytvořená vlákna, uvolníte Vámi alokované prostředky a vrátíte se z volání TerroristHunter.
Jak vyhledávat teroristy: na rozdíl od reálné situace uvažujeme řadu zjednodušení. Obrázky vyhledáváme na přesnou shodu (neuvažujeme zmenšení, zvětšení, natočení, intenzitu osvětlení ani změnu vzhledu hledaných osob). Úloha je tedy variantou vyhledávání matice v matici. Aby byla výpočetně náročnější (a aby více vyniklo paralení zpracování vlákny), předpokládáme, že obrázek teroristy v databázi má vymaskované pozadí. Hodnoty barvy 0-254 v obrázku teroristy se musí přesně shodovat s hodnotou barvy v obrazu. Pokud má nějaký prvek v obrazu teroristy hodnotu 255, jedná se o pozadí, které neuvažujeme (tedy na prohledávaném obrazu v tomto místě může být cokoliv). Příklad je v přiloženém zdrojovém kódu. První obrázek (i0) obsahuje teroristy t0 a t1. Druhý obrázek (i1) obsahuje teroristu t1 a třetí obrázek neobsahuje žádného.

Odevzdávejte zdrojový kód s implementací požadované funkce TerroristHunter a s případnými dalšími podpůrnými funkcemi, které Vaše implementace potřebuje. Deklarace struktury TIMAGE ponechte v bloku podmíněného překladu. Za základ implementace můžete použít přiložený příklad použití (vzorová data). Do Vaší implementace nevkládejte funkci main ani direktivy pro vkládání hlavičkových souborů. Funkci main a hlavičkové soubory lze pomechat pouze v případě, že jsou zabalené v bloku podmíněného překladu (viz přiložená vzorová data). Při implementaci nepoužívejte STL.

Nápověda:
Pokud je ze scanneru čteno celkem n obrázků a máme vyhledávat m teroristů, pak je potřeba pro celkem m x n vyhledat teroristu v obrázku. Každé vyhledání může trvat různě douho (v závislosti na velikosti obrázků). Proto je vhodné přidělovat výpočetní problémy jemně. Umožněte výpočet každého z m x n vyhledání vláknem, které je právě volné. Zkuste problém převést na nějakou modelovou synchronizační úlohu.
Pokud je obrázek teroristy větší než obrázek z kamery, pak prohledání nemusíte provádět - terorista tam není (ale testovací prostředí takové vstupy nezadává).
Funkce TerroristHunter je volaná opakovaně, pro různé vstupy. Nespoléhejte se na inicializaci globálních proměnných - při druhém a dalším zavolání budou mít globální proměné hodnotu jinou. Je rozumné případné globální proměnné inicializovat na začátku funkce TerroristHunter.
Nepoužívejte mutexy a podmíněné proměnné inicializované pomocí PTHREAD_MUTEX_INITIALIZER, důvod je stejný jako v minulém odstavci. Použijte raději pthread_mutex_init().
Testovací prostředí samo o sobě nevytváří žádná vlákna, tedy funkce TerroristHunter sama o sobě nemusí být reentrantní (může používat globální proměnné).
Obrázky, které dostanete (v databázi, načtené ze scanneru) alokovalo testovací prostředí. Testovací prostředí se také postará o jejich uvolnění (po dokončení práce, resp. po převzetí funkcí officer). Jejich uvolnění tedy není Vaší starostí. Musíte ovšem uvolňovat ty prostředky, které si alokujete Vy sami.
Vlastní vyhledávání obrázku v obrázku lze naprogramovat pomocí funkce (či lépe 2 funkcí), které mají dohromady cca 20 řádek kódu (včetně hlaviček a deklarací proměnných).
Pokud má obrázek teroristy velikost Wt x Ht a obrázek z kamery Wk x Hk, pak obrázek teroristy musíte přiložit a porovnat celkově na (Wk - Wt + 1) x (Hk - Ht + 1) místech. Neuvažujte situaci, že by část obrázku teroristy obsahující pouze pozadí byla mimo obrázek kamery.
Obrázky musíte načtat, zpracovávat a odevzdávat průběžně. Postup, kdy si všechny obrázky načtete do paměťových struktur a pak je začnete zpracovávat, nebude fungovat.